/*++

    Copyright (c) Microsoft Corporation.
    Licensed under the MIT License.

Abstract:

    Demo client application for the Sensor Protocol Over QUIC (SPQO). See the
README.MD at the top level for build and run instructions.

    Built upon msquic "sample" application.

--*/

#pragma once
#include <stdio.h>
#include <stdlib.h>

#include "msquic.h"

//
// Helper functions to look up a command line arguments.
//
BOOLEAN
GetFlag(_In_ int argc, _In_reads_(argc) _Null_terminated_ char* argv[],
        _In_z_ const char* name) {
  const size_t nameLen = strlen(name);
  for (int i = 0; i < argc; i++) {
    if (_strnicmp(argv[i] + 1, name, nameLen) == 0 &&
        strlen(argv[i]) == nameLen + 1) {
      return TRUE;
    }
  }
  return FALSE;
}

_Ret_maybenull_ _Null_terminated_ const char* GetValue(
    _In_ int argc, _In_reads_(argc) _Null_terminated_ char* argv[],
    _In_z_ const char* name) {
  const size_t nameLen = strlen(name);
  for (int i = 0; i < argc; i++) {
    if (_strnicmp(argv[i] + 1, name, nameLen) == 0 &&
        strlen(argv[i]) > 1 + nameLen + 1 && *(argv[i] + 1 + nameLen) == ':') {
      return argv[i] + 1 + nameLen + 1;
    }
  }
  return NULL;
}

//
// Helper function to convert a hex character to its decimal value.
//
uint8_t DecodeHexChar(_In_ char c) {
  if (c >= '0' && c <= '9') return c - '0';
  if (c >= 'A' && c <= 'F') return 10 + c - 'A';
  if (c >= 'a' && c <= 'f') return 10 + c - 'a';
  return 0;
}

//
// Helper function to convert a string of hex characters to a byte buffer.
//
uint32_t DecodeHexBuffer(_In_z_ const char* HexBuffer,
                         _In_ uint32_t OutBufferLen,
                         _Out_writes_to_(OutBufferLen, return)
                             uint8_t* OutBuffer) {
  uint32_t HexBufferLen = (uint32_t)strlen(HexBuffer) / 2;
  if (HexBufferLen > OutBufferLen) {
    return 0;
  }

  for (uint32_t i = 0; i < HexBufferLen; i++) {
    OutBuffer[i] = (DecodeHexChar(HexBuffer[i * 2]) << 4) |
                   DecodeHexChar(HexBuffer[i * 2 + 1]);
  }

  return HexBufferLen;
}

void EncodeHexBuffer(_In_reads_(BufferLen) uint8_t* Buffer,
                     _In_ uint8_t BufferLen,
                     _Out_writes_bytes_(2 * BufferLen) char* HexString) {
#define HEX_TO_CHAR(x) ((x) > 9 ? ('a' + ((x) - 10)) : '0' + (x))
  for (uint8_t i = 0; i < BufferLen; i++) {
    HexString[i * 2] = HEX_TO_CHAR(Buffer[i] >> 4);
    HexString[i * 2 + 1] = HEX_TO_CHAR(Buffer[i] & 0xf);
  }
}

void WriteSslKeyLogFile(_In_z_ const char* FileName,
                        _In_ QUIC_TLS_SECRETS* TlsSecrets) {
  printf("Writing SSLKEYLOGFILE at %s\n", FileName);
  FILE* File = NULL;
  File = fopen(FileName, "ab");

  if (File == NULL) {
    printf("Failed to open sslkeylogfile %s\n", FileName);
    return;
  }
  if (fseek(File, 0, SEEK_END) == 0 && ftell(File) == 0) {
    fprintf(File, "# TLS 1.3 secrets log file, generated by msquic\n");
  }

  char ClientRandomBuffer[(2 * sizeof(((QUIC_TLS_SECRETS*)0)->ClientRandom)) +
                          1] = {0};

  char TempHexBuffer[(2 * QUIC_TLS_SECRETS_MAX_SECRET_LEN) + 1] = {0};
  if (TlsSecrets->IsSet.ClientRandom) {
    EncodeHexBuffer(TlsSecrets->ClientRandom,
                    (uint8_t)sizeof(TlsSecrets->ClientRandom),
                    ClientRandomBuffer);
  }

  if (TlsSecrets->IsSet.ClientEarlyTrafficSecret) {
    EncodeHexBuffer(TlsSecrets->ClientEarlyTrafficSecret,
                    TlsSecrets->SecretLength, TempHexBuffer);
    fprintf(File, "CLIENT_EARLY_TRAFFIC_SECRET %s %s\n", ClientRandomBuffer,
            TempHexBuffer);
  }

  if (TlsSecrets->IsSet.ClientHandshakeTrafficSecret) {
    EncodeHexBuffer(TlsSecrets->ClientHandshakeTrafficSecret,
                    TlsSecrets->SecretLength, TempHexBuffer);
    fprintf(File, "CLIENT_HANDSHAKE_TRAFFIC_SECRET %s %s\n", ClientRandomBuffer,
            TempHexBuffer);
  }

  if (TlsSecrets->IsSet.ServerHandshakeTrafficSecret) {
    EncodeHexBuffer(TlsSecrets->ServerHandshakeTrafficSecret,
                    TlsSecrets->SecretLength, TempHexBuffer);
    fprintf(File, "SERVER_HANDSHAKE_TRAFFIC_SECRET %s %s\n", ClientRandomBuffer,
            TempHexBuffer);
  }

  if (TlsSecrets->IsSet.ClientTrafficSecret0) {
    EncodeHexBuffer(TlsSecrets->ClientTrafficSecret0, TlsSecrets->SecretLength,
                    TempHexBuffer);
    fprintf(File, "CLIENT_TRAFFIC_SECRET_0 %s %s\n", ClientRandomBuffer,
            TempHexBuffer);
  }

  if (TlsSecrets->IsSet.ServerTrafficSecret0) {
    EncodeHexBuffer(TlsSecrets->ServerTrafficSecret0, TlsSecrets->SecretLength,
                    TempHexBuffer);
    fprintf(File, "SERVER_TRAFFIC_SECRET_0 %s %s\n", ClientRandomBuffer,
            TempHexBuffer);
  }

  fflush(File);
  fclose(File);
}

const char* QuicStreamEventTypeToString(QUIC_STREAM_EVENT_TYPE type) {
    switch (type) {
        case QUIC_STREAM_EVENT_START_COMPLETE: return "START_COMPLETE";
        case QUIC_STREAM_EVENT_RECEIVE: return "RECEIVE";
        case QUIC_STREAM_EVENT_SEND_COMPLETE: return "SEND_COMPLETE";
        case QUIC_STREAM_EVENT_PEER_SEND_SHUTDOWN: return "PEER_SEND_SHUTDOWN";
        case QUIC_STREAM_EVENT_PEER_SEND_ABORTED: return "PEER_SEND_ABORTED";
        case QUIC_STREAM_EVENT_PEER_RECEIVE_ABORTED: return "PEER_RECEIVE_ABORTED";
        case QUIC_STREAM_EVENT_SEND_SHUTDOWN_COMPLETE: return "SEND_SHUTDOWN_COMPLETE";
        case QUIC_STREAM_EVENT_SHUTDOWN_COMPLETE: return "SHUTDOWN_COMPLETE";
        case QUIC_STREAM_EVENT_IDEAL_SEND_BUFFER_SIZE: return "IDEAL_SEND_BUFFER_SIZE";
        default: return "UNKNOWN_EVENT";
    }
}

const char* QuicConnectionEventTypeToString(QUIC_CONNECTION_EVENT_TYPE type) {
    switch (type) {
        case QUIC_CONNECTION_EVENT_CONNECTED: return "CONNECTED";
        case QUIC_CONNECTION_EVENT_SHUTDOWN_INITIATED_BY_TRANSPORT: return "SHUTDOWN_INITIATED_BY_TRANSPORT";
        case QUIC_CONNECTION_EVENT_SHUTDOWN_INITIATED_BY_PEER: return "SHUTDOWN_INITIATED_BY_PEER";
        case QUIC_CONNECTION_EVENT_SHUTDOWN_COMPLETE: return "SHUTDOWN_COMPLETE";
        case QUIC_CONNECTION_EVENT_LOCAL_ADDRESS_CHANGED: return "LOCAL_ADDRESS_CHANGED";
        case QUIC_CONNECTION_EVENT_PEER_ADDRESS_CHANGED: return "PEER_ADDRESS_CHANGED";
        case QUIC_CONNECTION_EVENT_PEER_STREAM_STARTED: return "PEER_STREAM_STARTED";
        case QUIC_CONNECTION_EVENT_STREAMS_AVAILABLE: return "STREAMS_AVAILABLE";
        case QUIC_CONNECTION_EVENT_PEER_NEEDS_STREAMS: return "PEER_NEEDS_STREAMS";
        case QUIC_CONNECTION_EVENT_IDEAL_PROCESSOR_CHANGED: return "IDEAL_PROCESSOR_CHANGED";
        case QUIC_CONNECTION_EVENT_DATAGRAM_STATE_CHANGED: return "DATAGRAM_STATE_CHANGED";
        case QUIC_CONNECTION_EVENT_DATAGRAM_RECEIVED: return "DATAGRAM_RECEIVED";
        case QUIC_CONNECTION_EVENT_DATAGRAM_SEND_STATE_CHANGED: return "DATAGRAM_SEND_STATE_CHANGED";
        case QUIC_CONNECTION_EVENT_RESUMED: return "RESUMED";
        case QUIC_CONNECTION_EVENT_RESUMPTION_TICKET_RECEIVED: return "RESUMPTION_TICKET_RECEIVED";
        case QUIC_CONNECTION_EVENT_PEER_CERTIFICATE_RECEIVED: return "PEER_CERTIFICATE_RECEIVED";
        default: return "UNKNOWN_EVENT";
    }
}
